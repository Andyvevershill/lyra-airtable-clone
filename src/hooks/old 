// "use client";

// import { useSavingStore } from "@/app/stores/use-saving-store";
// import { api } from "@/trpc/react";
// import type { TransformedRow } from "@/types/row";

// interface Params {
//   localRows: TransformedRow[];
//   setLocalRows: React.Dispatch<React.SetStateAction<TransformedRow[]>>;
// }

// export function useCellCommitter({ localRows, setLocalRows }: Params) {
//   const setIsSaving = useSavingStore((s) => s.setIsSaving);

//   // ‚úÖ Updated to use upsertCell instead of updateCell
//   const mutation = api.column.upsertCell.useMutation({
//     onMutate: ({ rowId, columnId, value }) => {
//       const mutationStart = performance.now();
//       console.log(
//         `üîµ [CellCommit] onMutate START - row: ${rowId.slice(0, 8)}, col: ${columnId.slice(0, 8)}, value: "${value}"`,
//       );

//       setIsSaving(true);

//       console.log(
//         `‚è±Ô∏è [CellCommit] onMutate took: ${(performance.now() - mutationStart).toFixed(2)}ms`,
//       );
//     },
//     onSuccess: (data, variables) => {
//       console.log(`üéâ [CellCommit] onSuccess - cellId: ${data.id}`);
//     },
//     onError: (error, variables) => {
//       console.error(`‚ùå [CellCommit] onError:`, error);
//     },
//     onSettled: () => {
//       console.log(`üèÅ [CellCommit] onSettled - saving state cleared`);
//       setIsSaving(false);
//     },
//   });

//   const commitCell = (
//     rowId: string,
//     columnId: string,
//     value: string | null,
//   ) => {
//     const commitStart = performance.now();
//     console.log(
//       `üìù [CellCommit] commitCell called - row: ${rowId.slice(0, 8)}, col: ${columnId.slice(0, 8)}`,
//     );

//     const row = localRows.find((r) => r._rowId === rowId);

//     // ‚úÖ Optimistic update - update local state immediately
//     const updateStart = performance.now();
//     setLocalRows((prev) =>
//       prev.map((r) => {
//         if (r._rowId !== rowId) return r;

//         // Update the cell value in the cells map
//         const updatedCells = { ...r._cells, [columnId]: value };

//         // If cell doesn't exist yet, add it to cellMap with temp ID
//         const cellId = r._cellMap[columnId];
//         const updatedCellMap = cellId
//           ? r._cellMap
//           : { ...r._cellMap, [columnId]: `temp-${rowId}-${columnId}` };

//         return {
//           ...r,
//           _cells: updatedCells,
//           _cellMap: updatedCellMap,
//         };
//       }),
//     );
//     console.log(
//       `‚è±Ô∏è [CellCommit] Local state update: ${(performance.now() - updateStart).toFixed(2)}ms`,
//     );

//     // ‚úÖ No longer needs cellId - backend will create if doesn't exist
//     const mutateStart = performance.now();
//     mutation.mutate({ rowId, columnId, value });
//     console.log(
//       `‚è±Ô∏è [CellCommit] mutation.mutate call: ${(performance.now() - mutateStart).toFixed(2)}ms`,
//     );
//     console.log(
//       `‚è±Ô∏è‚è±Ô∏è [CellCommit] Total commitCell: ${(performance.now() - commitStart).toFixed(2)}ms`,
//     );
//   };

//   return { commitCell };
// }

// import { createTRPCRouter, protectedProcedure } from "@/server/api/trpc";
// import { cells, columns, rows } from "@/server/db/schemas";
// import { TRPCError } from "@trpc/server";
// import { and, eq, sql } from "drizzle-orm";
// import { z } from "zod";

// export const columnRouter = createTRPCRouter({
//   getColumns: protectedProcedure
//     .input(z.object({ tableId: z.string() }))
//     .query(async ({ ctx, input }) => {
//       const columnArr = await ctx.db.query.columns.findMany({
//         where: eq(columns.tableId, input.tableId),
//         orderBy: (columns, { asc }) => [asc(columns.position)],
//       });

//       return columnArr;
//     }),

//   addColumn: protectedProcedure
//     .input(
//       z.object({
//         tableId: z.string(),
//         name: z.string(),
//         type: z.string(),
//       }),
//     )
//     .mutation(async ({ ctx, input }) => {
//       // Get max position for new column
//       const maxPositionResult = await ctx.db.query.columns.findFirst({
//         where: eq(columns.tableId, input.tableId),
//         orderBy: (columns, { desc }) => [desc(columns.position)],
//       });

//       const newPosition = (maxPositionResult?.position ?? -1) + 1;

//       // Create the column
//       const [newColumn] = await ctx.db
//         .insert(columns)
//         .values({
//           tableId: input.tableId,
//           name: input.name,
//           type: input.type,
//           position: newPosition,
//         })
//         .returning();

//       if (!newColumn) throw new Error("Failed to create column");

//       // Get ALL existing rows
//       const tableRows = await ctx.db.query.rows.findMany({
//         where: eq(rows.tableId, input.tableId),
//       });

//       // Create a cell for EACH row in the new column
//       if (tableRows.length > 0) {
//         await ctx.db.insert(cells).values(
//           tableRows.map((row) => ({
//             rowId: row.id,
//             columnId: newColumn.id,
//             value: null,
//           })),
//         );
//       }

//       return newColumn;
//     }),

//   addColumnBatched: protectedProcedure
//     .input(
//       z.object({
//         tableId: z.string(),
//         name: z.string(),
//         type: z.enum(["text", "number"]),
//       }),
//     )
//     .mutation(async ({ ctx, input }) => {
//       // Get max position for new column
//       const maxPositionResult = await ctx.db.query.columns.findFirst({
//         where: eq(columns.tableId, input.tableId),
//         orderBy: (columns, { desc }) => [desc(columns.position)],
//       });

//       const newPosition = (maxPositionResult?.position ?? -1) + 1;

//       // Create the column
//       const [newColumn] = await ctx.db
//         .insert(columns)
//         .values({
//           tableId: input.tableId,
//           name: input.name,
//           type: input.type,
//           position: newPosition,
//         })
//         .returning();

//       if (!newColumn) throw new Error("Failed to create column");

//       // Get the total row count first
//       const countResult = await ctx.db
//         .select({ count: sql<number>`count(*)` })
//         .from(rows)
//         .where(eq(rows.tableId, input.tableId));

//       const totalRows = countResult[0]?.count ?? 0;

//       if (totalRows === 0) {
//         return newColumn;
//       }

//       const batchSize = 1000;
//       const batches = Math.ceil(totalRows / batchSize);

//       for (let batch = 0; batch < batches; batch++) {
//         const offset = batch * batchSize;

//         // Fetch rows in batches
//         const tableRows = await ctx.db.query.rows.findMany({
//           where: eq(rows.tableId, input.tableId),
//           orderBy: (rows, { asc }) => [asc(rows.position)],
//           limit: batchSize,
//           offset: offset,
//         });

//         // Create cells for this batch
//         const cellsToInsert = tableRows.map((row) => ({
//           rowId: row.id,
//           columnId: newColumn.id,
//           value: null,
//           updatedAt: null,
//         }));

//         await ctx.db.insert(cells).values(cellsToInsert);
//       }

//       return newColumn;
//     }),

//   updateCell: protectedProcedure
//     .input(
//       z.object({
//         cellId: z.string(),
//         value: z.string().nullable() || z.number().nullable(),
//       }),
//     )
//     .mutation(async ({ ctx, input }) => {
//       const updatedCell = await ctx.db
//         .update(cells)
//         .set({ value: input.value })
//         .where(eq(cells.id, input.cellId));

//       return updatedCell;
//     }),

//   // In your column router
//   deleteColumn: protectedProcedure
//     .input(
//       z.object({
//         columnId: z.string(),
//       }),
//     )
//     .mutation(async ({ ctx, input }) => {
//       // Get the column first to know which table it belongs to
//       const column = await ctx.db.query.columns.findFirst({
//         where: eq(columns.id, input.columnId),
//       });

//       if (!column) {
//         throw new TRPCError({
//           code: "NOT_FOUND",
//           message: "Column not found",
//         });
//       }

//       // Delete the column
//       await ctx.db.delete(columns).where(eq(columns.id, input.columnId));

//       // ‚úÖ Return the tableId so the client can invalidate queries
//       return {
//         success: true,
//         tableId: column.tableId,
//       };
//     }),

//   // Add this to your column/cell router

//   upsertCell: protectedProcedure
//     .input(
//       z.object({
//         rowId: z.string(),
//         columnId: z.string(),
//         value: z.string().nullable(),
//       }),
//     )
//     .mutation(async ({ ctx, input }) => {
//       const mutationStart = Date.now();
//       console.log(
//         `üîß [upsertCell] START - rowId: ${input.rowId}, columnId: ${input.columnId}`,
//       );

//       // ‚úÖ Check if cell exists using composite key
//       const lookupStart = Date.now();
//       const existingCell = await ctx.db.query.cells.findFirst({
//         where: and(
//           eq(cells.rowId, input.rowId),
//           eq(cells.columnId, input.columnId),
//         ),
//       });
//       console.log(`‚è±Ô∏è [upsertCell] Cell lookup: ${Date.now() - lookupStart}ms`);

//       let result;

//       if (existingCell) {
//         // Update existing cell
//         console.log(
//           `üìù [upsertCell] Found existing cell ${existingCell.id}, updating...`,
//         );
//         const updateStart = Date.now();

//         [result] = await ctx.db
//           .update(cells)
//           .set({
//             value: input.value,
//             updatedAt: new Date(),
//           })
//           .where(eq(cells.id, existingCell.id))
//           .returning();

//         console.log(
//           `‚è±Ô∏è [upsertCell] Update query: ${Date.now() - updateStart}ms`,
//         );
//       } else {
//         // ‚úÖ Create new cell (lazy creation)
//         console.log(`üÜï [upsertCell] Cell not found, creating new cell...`);
//         const insertStart = Date.now();

//         [result] = await ctx.db
//           .insert(cells)
//           .values({
//             rowId: input.rowId,
//             columnId: input.columnId,
//             value: input.value,
//             updatedAt: new Date(),
//           })
//           .returning();

//         console.log(
//           `‚è±Ô∏è [upsertCell] Insert query: ${Date.now() - insertStart}ms`,
//         );
//       }

//       console.log(
//         `‚è±Ô∏è‚è±Ô∏è [upsertCell] TOTAL MUTATION: ${Date.now() - mutationStart}ms`,
//       );
//       console.log(`‚úÖ [upsertCell] Completed - cellId: ${result?.id}`);

//       return result;
//     }),
// });

// import {
//   translateFiltersState,
//   translateSortingState,
// } from "@/lib/helper-functions";
// import { api } from "@/trpc/react";
// import type { ColumnFiltersState, SortingState } from "@tanstack/react-table";
// import { memo, useCallback, useEffect, useRef } from "react";
// import { AiOutlinePlus } from "react-icons/ai";

// interface Props {
//   tableId: string;
//   sorting: SortingState;
//   filters: ColumnFiltersState;
//   columns: any[];
// }

// function AddRowButton({ tableId, sorting, filters, columns }: Props) {
//   const utils = api.useUtils();
//   const mountCount = useRef(0);
//   const renderCount = useRef(0);

//   useEffect(() => {
//     mountCount.current += 1;
//     console.log(`üîµ [AddRowButton] MOUNTED (mount #${mountCount.current})`);
//     return () => {
//       console.log(
//         `üî¥ [AddRowButton] UNMOUNTED (was mount #${mountCount.current})`,
//       );
//     };
//   }, []);

//   useEffect(() => {
//     renderCount.current += 1;
//     console.log(`üîÑ [AddRowButton] RENDERED (render #${renderCount.current})`);
//   });

//   const addRow = api.row.addRow.useMutation({
//     onMutate: async () => {
//       const traceId = `add-row-${Date.now()}`;
//       const startTime = performance.now();
//       console.log(`üü¢ [${traceId}] Starting optimistic row add`);

//       const queryKey = {
//         tableId,
//         limit: 5000,
//         sorting: translateSortingState(sorting, columns),
//         filters: translateFiltersState(filters, columns),
//       };

//       const cancelStart = performance.now();
//       await utils.row.getRowsInfinite.cancel(queryKey);
//       console.log(
//         `‚è±Ô∏è [${traceId}] Cancel queries: ${(performance.now() - cancelStart).toFixed(2)}ms`,
//       );

//       const cacheStart = performance.now();
//       const previousData = utils.row.getRowsInfinite.getInfiniteData(queryKey);
//       console.log(
//         `‚è±Ô∏è [${traceId}] Get cache data: ${(performance.now() - cacheStart).toFixed(2)}ms`,
//       );

//       console.log(`üìä [${traceId}] Previous data:`, {
//         hasData: !!previousData,
//         firstPageItems: previousData?.pages?.[0]?.items?.length,
//       });

//       const tempRowId = `temp-${Date.now()}`;

//       if (!previousData) {
//         console.warn(`‚ö†Ô∏è [${traceId}] No cache data found`);
//         console.log(
//           `‚è±Ô∏è [${traceId}] Total onMutate: ${(performance.now() - startTime).toFixed(2)}ms`,
//         );
//         return {
//           previousData: null,
//           traceId,
//           queryKey,
//           tempRowId: null,
//           startTime,
//         };
//       }

//       const updateStart = performance.now();
//       utils.row.getRowsInfinite.setInfiniteData(queryKey, (old) => {
//         if (!old) return old;

//         const newRow = {
//           id: tempRowId,
//           tableId,
//           position: old.pages[0]?.items.length ?? 0,
//           createdAt: new Date(),
//           updatedAt: new Date(),
//           cells: [],
//         };

//         console.log(
//           `‚úÖ [${traceId}] Adding optimistic row at position ${newRow.position}`,
//         );

//         return {
//           ...old,
//           pages: old.pages.map((page, index) =>
//             index === 0 ? { ...page, items: [...page.items, newRow] } : page,
//           ),
//         };
//       });
//       console.log(
//         `‚è±Ô∏è [${traceId}] Set cache data: ${(performance.now() - updateStart).toFixed(2)}ms`,
//       );
//       console.log(
//         `‚è±Ô∏è [${traceId}] Total onMutate: ${(performance.now() - startTime).toFixed(2)}ms`,
//       );

//       return { previousData, traceId, queryKey, tempRowId, startTime };
//     },

//     onError: (err, _variables, context) => {
//       console.error(`‚ùå [${context?.traceId}] Mutation FAILED:`, err);
//       if (context?.startTime) {
//         console.log(
//           `‚è±Ô∏è [${context.traceId}] Total time to error: ${(performance.now() - context.startTime).toFixed(2)}ms`,
//         );
//       }

//       if (context?.previousData && context?.queryKey) {
//         console.log(`‚Ü©Ô∏è [${context?.traceId}] Rolling back`);
//         utils.row.getRowsInfinite.setInfiniteData(
//           context.queryKey,
//           context.previousData,
//         );
//       }
//     },

//     onSuccess: (serverRow, _variables, context) => {
//       const successStart = performance.now();
//       console.log(`üéâ [${context?.traceId}] SUCCESS - ${serverRow.id}`);

//       if (context?.startTime) {
//         const mutationTime = successStart - context.startTime;
//         console.log(
//           `‚è±Ô∏è [${context.traceId}] Network + DB mutation: ${mutationTime.toFixed(2)}ms`,
//         );
//       }

//       if (!context?.previousData || !context?.tempRowId) {
//         console.log(`‚ö†Ô∏è [${context?.traceId}] Fallback: invalidating`);
//         void utils.row.getRowsInfinite.invalidate({ tableId });
//         void utils.row.getRowCount.invalidate({ tableId });
//         return;
//       }

//       console.log(`üíæ [${context?.traceId}] Updating cache (no invalidate)`);
//       const newRow = { ...serverRow, cells: [] };

//       const cacheUpdateStart = performance.now();

//       // ‚úÖ FIRST: Update the data
//       utils.row.getRowsInfinite.setInfiniteData(context.queryKey, (old) => {
//         if (!old) return old;

//         return {
//           ...old,
//           pages: old.pages.map((page, i) => {
//             if (i !== 0) return page;

//             const lastIndex = page.items.length - 1;

//             if (page.items[lastIndex]?.id === context.tempRowId) {
//               console.log(
//                 `üîç [${context.traceId}] Replacing temp row at index ${lastIndex}`,
//               );
//               const newItems = [...page.items];
//               newItems[lastIndex] = newRow;
//               return { ...page, items: newItems };
//             }

//             console.warn(
//               `‚ö†Ô∏è [${context.traceId}] Temp row not at expected position, searching...`,
//             );
//             const tempIndex = page.items.findIndex(
//               (item) => item.id === context.tempRowId,
//             );

//             if (tempIndex === -1) {
//               console.error(`‚ùå [${context.traceId}] Temp row not found!`);
//               return page;
//             }

//             const newItems = [...page.items];
//             newItems[tempIndex] = newRow;
//             return { ...page, items: newItems };
//           }),
//         };
//       });

//       console.log(
//         `‚è±Ô∏è [${context.traceId}] Cache update: ${(performance.now() - cacheUpdateStart).toFixed(2)}ms`,
//       );

//       // ‚úÖ THEN: Update count to match (count already includes the optimistic row)
//       // The optimistic update already added +1 to the UI, so count is already correct
//       // We just need to verify the server agrees
//       const currentData = utils.row.getRowsInfinite.getInfiniteData(
//         context.queryKey,
//       );
//       const actualItemCount =
//         currentData?.pages.reduce((sum, page) => sum + page.items.length, 0) ??
//         0;

//       console.log(
//         `üî¢ [${context.traceId}] Syncing count to match actual items: ${actualItemCount}`,
//       );
//       utils.row.getRowCount.setData({ tableId }, actualItemCount);

//       console.log(`‚úì [${context?.traceId}] Cache updated`);

//       if (context?.startTime) {
//         console.log(
//           `‚è±Ô∏è [${context.traceId}] Total onSuccess: ${(performance.now() - successStart).toFixed(2)}ms`,
//         );
//         console.log(
//           `‚è±Ô∏è‚è±Ô∏è [${context.traceId}] TOTAL END-TO-END: ${(performance.now() - context.startTime).toFixed(2)}ms`,
//         );
//       }
//     },

//     onSettled: () => {
//       // Removed
//     },
//   });

//   const handleClick = useCallback(() => {
//     console.log(`üñ±Ô∏è [AddRowButton] Button clicked`);
//     addRow.mutate({ tableId });
//   }, [addRow, tableId]);

//   return (
//     <button
//       className="pointer flex h-full w-full items-center justify-start pl-2 hover:bg-gray-50"
//       title="Add row"
//       onClick={handleClick}
//       disabled={addRow.isPending}
//     >
//       <AiOutlinePlus size={16} className="text-gray-600" />
//     </button>
//   );
// }

// export default memo(AddRowButton);
